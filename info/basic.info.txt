Every app starts from idea, and from planing what app should do and how it should be used.
We need to white a few diagrams, and pictures what the main flows.

For app that collects feedback for apps - the main flow should be something like this.
User signs up via Google OAuth (sign with 'google' account) -> (Express, MongoDB, PassportJS)
User pays for email credits via stripe -> (Stripe + MongoDB)
User creates a new "campaign" -> (React + Redux)
User enters a list of emails to send question survey to -> (React + Redux + Redux Form)
App sends emails to list -> (Email Provider)
Surveys clicks on links in email to provide feedback -> (Express, MongoDB, Email Provider)
App tabulate feedback -> (MongoDB ?)
User can see report of all survey responses. (React + Redux + MongoDB)

Architecture:
React App <-> Express API Server <-> MongoDB. Client doesn't talk to DB directly.

OAuth login.
We show user - "Login with google". User clicks -> redirecting him to google (with our app ID) where google asks user
"Do you grant permission for this app (ID) to get info about yourself?" -> User clicks yes, Google gives our app "user
code" means User has granted permission, app asks google to exchange "user code" on information about the User, google
returns to the app User profile. App create a User record in DB, and gives User cookies (e.g. JWT). Further User
requests to App User makes with cookies.
All things that related to google auth - is passportJS http://www.passportjs.org/ library responsibilities.
https://console.developers.google.com/ - here we can add a appID.
Your need to setup your application: enable Google+ API to get OAuth2.0. Create a ClientID - which brings you to setup
consent screen - screen that google shows User so he can grant app the permission to get his data.
ClientID - Public token (key) of our app in google developers console. ClientSecret - is a private token (key), don't
share it.
Also to avoid redirect "redirect_uri_mismatch" error - you need to provide a valid links you setup to redirect to.
Those links Google with match with it's "hackers base", if everything is ok - than google will send user access' code
to your app, with this access code you can ask google to get info about the user or some more stuff. So access
code is like a permission to access user info from your app, but it expires with time, that's why google sends you the
Refresh token, with this token you can get new access token.

In passport JS we can ask for scope of information user should give access to e.g. we can ask for photos from google
drive, contact list, calendar, a lot of stuff.

When you get the User profile, you can generate a token based on this profile and ask passport.js to stick this token
to the user cookie. This can be done with implementation of serialize function in passport.js, which gets a User model
as an argument and serialize it to token.
When User will return to our app with his token - another function that we need to implement is deserialize, that gets
token as an argument and returns the User model.

cookieSession and passport
cookieSession when request comes in, extracts all cookie data from request and adds it to req.session property, so
passport don't have to worry about cookie, it has to grab data from req.session property and deserialize it to req.user.
So req.session - it's a cookieSession's work, req.user - passport's work.
When we send the request cookieSession grabs data from req.session (?) and assign it to response cookie.

Express says that we can also use express-session package instead of cookie-session. Difference is between storing
cookie data inside the app. Cookie-session stores the encrypted user id, and all stuff that we add to cookie, so only
thing we need to do is decrypt it (which) done by cookie-session and cookie data in our needs.
Express-session stores in cookie only session id, it has it's session id storage where it can find a match of session id
and user data that this session id is belong to.
So cookie-session stores add data inside cookie, express-session - stores user data outside cookie. The nice thing in
express-session is that we can store a lot of data for particular session, because we don't need to pass all the stuff
via network to client, but the bad thing is we make our session not stateless on the server side. + we need to setup
external session storage, which makes our server on one dependency more.
===============================================
Some theory about login.
HTTP is stateless, about next request. So to login, server got to give you something (like JWT, cookie), that would give
you ability to say that you've been here lately, and you have rights to get this info you're asking.
If we talking about cookie-based authentication, server should add header "Set-Cookie": "aldskfluh" with some token to
response, browser will see this specific header, and store it in his memory, and automatically will append this header to
each further request (if you writing test with REST lib, you need to add it by yourself of course).

Simple login flow is different from OAuth flow.
Simple login: User sign up with login/pass, server stores them, User login with login/pass - server search the match and
know who's logged in.
OAuth flow - User sign up with Google, server stores his profile data gotten from Google, User login - server once again
goes to google to get profile data and search for match among created Users, then it understands who's logged in.
This a third-party (Google in this case) relation, but we make an assumption that data of the profile (e.g. UserID)
won't change with time, and User can always login to our app and sees his data.

When User logs out - server invalidate, unset, or expire "Set-Cookie" header, which makes user session invalid.

================================================
Mongo & mongoose
Mongo - it's about collections, and rows in these collections. It's pretty basic.
Mongoose - it's a js library above the Mongo, there are schemes, Models.
Model class - works with single collection, with addition features like inserting a record, find records, filter, so on.
Model class also gives us access to instance(s) of rows. It returns record, or records - depends what have you asked.
